input {

  # CoreOS journal input
  udp {
    codec => "line"
    port => 5000
    tags => ["coreos","docker"]
    type => "systemd"
  }

  udp {
    type => "haproxy-access"
    port => 514
  }
  
  udp {
    type => "nginx-access"
    port => 5001
  }

}
# Some Filtering
filter {
  # syslog/systemd filter
  if [type] == "syslog" or [type] == "systemd" {
    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{SYSLOGPROG}: %{GREEDYDATA:syslog_message}" }
      add_field => [ "received_at", "%{@timestamp}" ]
    }
    syslog_pri { }
    date { match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ] }

    if !("_grokparsefailure" in [tags]) {
      mutate {
        replace => { "message" => "%{syslog_message}" }
        remove_field => [  "syslog_message", "syslog_program" ]
      }
    }

    mutate { remove_field => [ "syslog_hostname", "syslog_timestamp" ] }
  }

 
  if [program] == "dockerd" {
    kv {
      source => "message"
      prefix => "docker_"
    }
    mutate {
      rename => { "docker_level" => "docker_loglevel" }
      replace => { "message" => "%{docker_msg}" }
      remove_field => [ "%{docker_msg}", "%{docker_time}" ]
    }
  }



  if [type] == "haproxy-access" {
      grok {
        match => ["message", "%{HAPROXYHTTP}"]
      }
  }
 
  if [type] == "nginx-access" {
     grok {
       match => { "message" => "%{NGINXACCESS}" }
     }
  }

}

# Where to send output
output {
  # Send output to standard output device/interface
  stdout {
    codec => rubydebug
  }

  # Parse failed messages to separate index
  if "_grokparsefailure" in [tags] or "_jsonparsefailure" in [tags] {
    elasticsearch {
      host => ["localhost:9200"]
    #  host => "$COREOS_PRIVATE_IPV4"
      index => "parse-err-%{+YYYY.MM.dd}"
      protocol  => "http"
    }
  }

# Elasticsearch output
  elasticsearch {
    host => ["localhost:9200"]
  #  host => "$COREOS_PRIVATE_IPV4"
    index => "logstash-%{+YYYY.MM.dd}"
    protocol  => "http"
  }
}
